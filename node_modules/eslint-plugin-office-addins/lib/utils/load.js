Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLoadArguments = exports.isLoadReference = exports.isLoadFunction = void 0;
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const utils_1 = require("./utils");
function isLoadFunction(node) {
    var _a;
    node = (0, utils_1.findTopLevelExpression)(node);
    return (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.AST_NODE_TYPES.CallExpression &&
        node.property.type === experimental_utils_1.TSESTree.AST_NODE_TYPES.Identifier &&
        node.property.name === "load");
}
exports.isLoadFunction = isLoadFunction;
function isLoadReference(node) {
    return (node.parent &&
        node.parent.type === experimental_utils_1.TSESTree.AST_NODE_TYPES.MemberExpression &&
        isLoadFunction(node.parent));
}
exports.isLoadReference = isLoadReference;
function parseObjectExpressionProperty(objectExpression) {
    let composedProperties = [];
    objectExpression.properties.forEach((property) => {
        if (property.type === experimental_utils_1.AST_NODE_TYPES.Property &&
            property.key.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
            let propertyName = property.key.name;
            if (property.value.type === experimental_utils_1.AST_NODE_TYPES.ObjectExpression) {
                const composedProperty = parseObjectExpressionProperty(property.value);
                if (composedProperty.length !== 0) {
                    composedProperties = composedProperties.concat(propertyName + "/" + composedProperty);
                }
            }
            else if (property.value.type === experimental_utils_1.AST_NODE_TYPES.Literal &&
                property.value.value // Checking if the value assigined to the property is true
            ) {
                composedProperties = composedProperties.concat(propertyName);
            }
        }
    });
    return composedProperties;
}
function parseLoadStringArgument(argument) {
    let properties = [];
    argument
        .replace(/\s/g, "")
        .split(",")
        .forEach((property) => {
        properties.push(property);
    });
    return properties;
}
function parseLoadArguments(node) {
    var _a;
    node = (0, utils_1.findTopLevelExpression)(node);
    if (isLoadFunction(node) &&
        ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.TSESTree.AST_NODE_TYPES.CallExpression) {
        const argument = node.parent.arguments[0];
        if (!argument) {
            return [];
        }
        let properties = [];
        if (argument.type === experimental_utils_1.AST_NODE_TYPES.ArrayExpression) {
            argument.elements.forEach((element) => {
                if (element.type === experimental_utils_1.TSESTree.AST_NODE_TYPES.Literal) {
                    properties = properties.concat(parseLoadStringArgument(element.value));
                }
            });
        }
        else if (argument.type === experimental_utils_1.TSESTree.AST_NODE_TYPES.Literal) {
            properties = properties.concat(parseLoadStringArgument(argument.value));
        }
        else if (argument.type === experimental_utils_1.TSESTree.AST_NODE_TYPES.ObjectExpression) {
            properties = properties.concat(parseObjectExpressionProperty(argument));
        }
        return properties;
    }
    throw new Error("error in getLoadArgument function.");
}
exports.parseLoadArguments = parseLoadArguments;
//# sourceMappingURL=load.js.map